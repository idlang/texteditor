// in progress ...

/*!
 * ==========================================================
 *  MARKDOWN TEXT EDITOR PLUGIN 1.0.0
 * ==========================================================
 * Author: Taufik Nurrohman <https://github.com/tovic>
 * License: MIT
 * ----------------------------------------------------------
 */

TE.Markdown = function(target, o) {

    var _u2013 = '\u2013', // N-dash
        _u2026 = '\u2026', // horizontal ellipsis
        _u2190 = '\u2190', // leftwards arrow
        _u2192 = '\u2192', // rightwards arrow
        _u2191 = '\u2191', // upwards arrow
        _u2193 = '\u2193', // downwards arrow
        _u21B5 = '\u21B5', // carriage return arrow
        _u2318 = '\u2318', // command sign
        _u2718 = '\u2718', // delete sign
        _u21E5 = '\u21E5', // indent sign
        _u21E7 = '\u21E7', // shift sign

        win = window,
        doc = document,
        editor = new TE.HTML(target),
        extend = editor._.extend,
        each = editor._.each,
        esc = editor._.x,
        format = editor._.format,
        config = editor.config,
        languages = config.languages,
        formats = config.formats,
        classes = config.classes,
        tab = config.tab,
        suffix = config.suffix,
        attrs = '(?:\\s[^<>]*?)?',
        attrs_capture = '(|\\s[^<>]*?)',
        content = '([\\s\\S]*?)',
        placeholder = languages.others.placeholder;

    extend(editor.config, {
        auto_p: 0,
        tools: 'clear | b i s | a img | p,h1,h2,h3,h4,h5,h6 | blockquote,q pre,code | ul ol | indent outdent | hr | undo redo',
        formats: {
            b: '**',
            i: '_',
            br: '  \n', // hard-break
            pre: '    ', // replace with `~~~\n%1\n~~~` to enable fenced code block syntax in Markdown Extra
            ul: '- ',
            ol: '%1. ',
            hr: '---'
        }
    });

    extend(editor.config, o);

    function is_node(x) {
        return x instanceof HTMLElement;
    }

    function is_function(x) {
        return typeof x === "function";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function pattern(a, b) {
        return new RegExp(a, b);
    }

    function trim(s) {
        return s.replace(/^\s*|\s*$/g, "");
    }

    function attr_value(s) {
        return s.replace(/<.*?>/g, "").replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    }

    editor.mark = function(str, wrap, gap_1, gap_2) {
        if (!is_set(gap_1)) gap_1 = ' ';
        if (!is_set(gap_2)) gap_2 = "";
        var s = r[0]().$(),
            a = str[0] + gap_2,
            b = gap_2 + (str[1] || str[0]),
            A = esc(a),
            B = esc(b),
            m = pattern('^' + A + '([\\s\\S]*?)' + B + '$'),
            m_A = pattern(A + '$'),
            m_B = pattern('^' + B),
            gap_11 = gap_1,
            gap_12 = gap_1,
            before = s.before,
            after = s.after;
        if (/<[^\/<>]+?>$/.test(before)) gap_11 = "";
        if (/^<\/[^<>]+?>/.test(after)) gap_12 = "";
        if (!s.length) {
            r.insert(i18n_others.placeholder);
        }
        return r.toggle(
            // when ...
            wrap ? !m.test(s.value) : (!m_A.test(before) && !m_B.test(after)),
            // do ...
            [
                // first toggle
                function($) {
                    $.unwrap(a, b, 1).tidy(gap_11, gap_12).wrap(a, b, wrap)[1]();
                },
                // second toggle (the reset state)
                function($) {
                    $.unwrap(a, b, wrap)[1]();
                }
            ]
        );
    };

    extend(ui.tools, {
        b: {
            i: 'bold',
            click: function(e, $) {
                return $.mark(formats.b), false;
            }
        },
        i: {
            i: 'italic',
            click: function(e, $) {
                return $.mark(formats.i), false;
            }
        },
        s: {
            i: 'strikethrough',
            click: function(e, $) {
                return $.mark(formats.s), false;
            }
        },
        a: {
            i: 'link',
            click: function(e, $) {
                var a = formats.a,
                    i18n = languages.modals.a,
                    href, title;
                return $.record().ui.prompt(i18n.title[0], i18n.placeholder[0], 1, function(e, $, v) {
                    href = v;
                    // automatic `rel="nofollow"` attribute
                    var host = win.location.host,
                        x, extra;
                    if (href.indexOf('://') !== -1) x = 1;
                    if (host !== "" && href.indexOf('://' + host) !== -1) x = 0;
                    if (/^([.\/?&#]|javascript:)/.test(href)) x = 0;
                    $.blur().ui.prompt(i18n.title[1], i18n.placeholder[1], 0, function(e, $, v) {
                        title = attr_value(v);
                        if (!auto_p_(e, $).$().length) {
                            $.insert(placeholder);
                        }
                        extra = x ? ' rel="nofollow" target="_blank"' : "";
                        $.format(a + ' href="' + href + '"' + (title ? ' title="' + title + '"' : "") + extra);
                    });
                }), false;
            }
        },
        img: {
            i: 'image',
            click: function(e, $) {
                var s = $.$(),
                    img = formats.img,
                    figure = formats.figure,
                    figcaption = formats.figcaption,
                    alt = s.value,
                    i18n = languages.modals.img,
                    src, title;
                return $.record().ui.prompt(i18n.title[0], i18n.placeholder[0], 1, function(e, $, v) {
                    src = v;
                    $.blur().ui.prompt(i18n.title[1], i18n.placeholder[1], 0, function(e, $, v) {
                        title = v;
                        if (!alt.length) {
                            alt = src.split(/[\/\\\\]/).pop();
                        }
                        alt = attr_value(alt);
                        $[0]().insert("");
                        if (!title) {
                            auto_p_(e, $).tidy(/<[^\/<>]+?>\s*$/.test($.$().before) ? "" : ' ', "").insert('<' + img + ' alt="' + alt + '" src="' + src + '"' + suffix + ' ', -1);
                        } else {
                            $.tidy('\n\n', "").insert('<' + figure + '>\n' + tab + '<' + img + ' alt="' + alt + '" src="' + src + '"' + suffix + '\n' + tab + '<' + figcaption + '>' + title + '</' + get_o(figcaption) + '>\n</' + get_o(figure) + '>\n\n', -1);
                            if (auto_p) {
                                ui.tools.p.click(e, editor);
                            }
                        }
                        $[1]();
                    });
                }), false;
            }
        },
        sub: {
            i: 'subscript',
            click: function(e, $) {
                var sub = formats.sub,
                    sup = formats.sup,
                    sup_o = get_o(sup);
                return auto_p_(e, $)[0]()
                    .unwrap(pattern('<' + sup_o + attrs + '>'), '</' + sup_o + '>')
                    .format(sub)
                [1](), false;
            }
        },
        sup: {
            i: 'superscript',
            click: function(e, $) {
                var sub = formats.sub,
                    sup = formats.sup,
                    sub_o = get_o(sub);
                return auto_p_(e, $)[0]()
                    .unwrap(pattern('<' + sub_o + attrs + '>'), '</' + sub_o + '>')
                    .format(sup)
                [1](), false;
            }
        },
        p: {
            i: 'paragraph',
            click: function(e, $) {
                var s = $.$(),
                    p = formats.p,
                    br = formats.br,
                    p_o = get_o(p),
                    br_o = get_o(br),
                    before = s.before,
                    after = s.after,
                    dent = get_indent(before);
                if (!s.length || s.value.indexOf('\n') === -1) {
                    if (pattern('^\\s*<\\/' + p_o + '>').test(after)) {
                        if (pattern('<' + p_o + attrs + '>\\s*$').test(before)) {
                            $[0]()
                                .unwrap(pattern('\\s*<' + p_o + attrs + '>\\s*'), pattern('\\s*<\\/' + p_o + '>'))
                                .tidy('\n', '\n' + dent)
                            [1]();
                        } else if (match = before.match(pattern('<' + p_o + attrs_capture + '>.*$'))) {
                            $.wrap('</' + p_o + '>\n' + dent + '<' + p_o + match[1] + '>', "");
                        }
                    } else {
                        $[0]().format(p, 0, '\n\n')[1]();
                    }
                } else {
                    var par = pattern('^(?:\\s*<' + p_o + attrs + '>\\s*)+' + content + '(?:\\s*<\\/' + p_o + '>\\s*)+$');
                    if (par.test(s.value)) {
                        $[0]()
                            .replace(par, '$1')
                            .replace(pattern('\\s*<\\/' + p_o + '>\\s*<' + p_o + attrs + '>\\s*', 'g'), '\n\n')
                            .replace(pattern('\\s*<' + br_o + attrs + '>\\s*', 'g'), '\n')
                        [1]();
                    } else {
                        $[0]()
                            .replace(/\n/g, '\n<' + br + suffix + '\n')
                            .replace(pattern('(\\s*<' + br_o + attrs + suffix + '\\s*){2,}', 'g'), '</' + p_o + '>\n<' + p + '>')
                            .wrap('<' + p + '>', '</' + p_o + '>', 1)
                            .replace(pattern('(<' + p_o + attrs + '>)+', 'g'), '$1')
                            .replace(pattern('(<\\/' + p_o + '>)+', 'g'), '$1')
                            .tidy('\n')
                        [1]();
                    }
                }
                return false;
            }
        },
        'p,h1,h2,h3,h4,h5,h6': {
            i: 'header',
            click: function(e, $) {
                var s = $.$(),
                    H = [
                        formats.p,
                        formats.h1,
                        formats.h2,
                        formats.h3,
                        formats.h4,
                        formats.h5,
                        formats.h6
                    ],
                    H_o = [];
                each(H, function(v, i) {
                    H_o[i] = get_o(v);
                });
                var tags = esc(H).join('|'),
                    tags_o = esc(H_o).join('|'),
                    o = '\\s*<(' + tags_o + ')' + attrs_capture + '>\\s*',
                    w_o = pattern('\\s*<(?:' + tags_o + ')' + attrs + '>\\s*'),
                    w_c = pattern('\\s*<\\/(?:' + tags_o + ')>\\s*'),
                    match = s.value.match(pattern('^' + o));
                if (!match) {
                    match = s.before.match(pattern(o + '$')) || [];
                }
                var attr = match[2] || "",
                    i = +((match[1] || 'h0').slice(1));
                return $[0]()
                    .replace(/\s+/g, ' ')
                    .unwrap(w_o, w_c)
                    .unwrap(w_o, w_c, 1)
                    .format(i > 5 ? H_o[0] + attr : H_o[i + 1] + attr, 0, '\n\n')
                [1](), false;
            }
        },
        'blockquote,q': {
            i: 'quote-left',
            click: function(e, $) {
                var s = $.$(),
                    blockquote = formats.blockquote,
                    q = formats.q,
                    p = formats.p,
                    p_o = get_o(p),
                    para = '<' + p_o + attrs + '>';
                // block
                if (pattern('(^|\\n|' + para + ')$').test(s.before)) {
                    if (auto_p && (s.value === placeholder || pattern('(' + para + ')$').test(s.before))) {
                        return $.select(), false;
                    }
                    $[0]().format(blockquote, 0, '\n\n', '\n');
                    if (auto_p) {
                        if (!s.length || $.match(/^[^<\n]*?[^>]$/)) {
                            $.wrap(tab + '<' + p + '>', '</' + p_o + '>');
                        } else {
                            $[pattern('((^|\\n)' + tab + ')+').test(s.value) ? 'outdent' : 'indent'](tab);
                        }
                    }
                    $[1]();
                // span
                } else {
                    $.format(q);
                }
                return false;
            }
        },
        'pre,code': {
            i: 'code',
            click: function(e, $) {
                var s = $.$(),
                    x = config.auto_encode_html,
                    pre = formats.pre,
                    code = formats.code,
                    pre_o = get_o(pre),
                    code_o = get_o(code),
                    B = '<' + pre_o + attrs + '>\\s*<' + code_o + attrs + '>\\s*',
                    A = '\\s*<\\/' + code_o + '>\\s*<\\/' + pre_o + '>',
                    before = pattern(B + '\\s*$'),
                    after = pattern('^\\s*' + A),
                    any = pattern('^' + content + '$');
                function encode(a) {
                    return x ? a.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : a;
                }
                function decode(a) {
                    return x ? a.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&') : a;
                }
                // block
                if (pattern('(^|\\n|' + B + ')$').test(s.before)) {
                    if (before.test(s.before) && after.test(s.after)) {
                        $[0]().unwrap(pattern(before), pattern(after)).replace(any, decode)[1]();
                    } else {
                        $[0]().tidy('\n\n').wrap('<' + pre + '><' + code + '>', '</' + code_o + '></' + pre_o + '>').insert(s.length ? s.value : placeholder).replace(any, encode)[1]();
                    }
                // span
                } else {
                    $[0]().format(code).loss().replace(any, function(a) {
                        return pattern('^<\\/' + code_o + '>').test($.$().after) ? encode(a) : decode(a);
                    })[1]();
                }
                return false;
            }
        },
        ul: {
            i: 'list-ul',
            click: function(e, $) {
                var ol = formats.ol,
                    ul = formats.ul,
                    ol_o = get_o(ol),
                    ul_o = get_o(ul),
                    s = ul_o + '|' + ol_o;
                if ($.match(pattern('<' + s + attrs + '>' + content + '<\\/' + s + '>'))) {
                    $[0]()
                        .replace(pattern('<' + ol_o + attrs_capture + '>', 'g'), '<' + ul_o + '$1>')
                        .replace(pattern('</' + ol_o + '>', 'g'), '</' + ul_o + '>')
                    [1]();
                } else {
                    tree(e, ul, formats.li);
                }
                return false;
            }
        },
        ol: {
            i: 'list-ol',
            click: function(e, $) {
                var ol = formats.ol,
                    ul = formats.ul,
                    ol_o = get_o(ol),
                    ul_o = get_o(ul),
                    s = ul_o + '|' + ol_o;
                if ($.match(pattern('<' + s + attrs + '>' + content + '<\\/' + s + '>'))) {
                    $[0]()
                        .replace(pattern('<' + ul_o + attrs_capture + '>', 'g'), '<' + ol_o + '$1>')
                        .replace(pattern('</' + ul_o + '>', 'g'), '</' + ol_o + '>')
                    [1]();
                } else {
                    tree(e, ol, formats.li);
                }
                return false;
            }
        },
        'align-left': align,
        'align-center': align,
        'align-right': align,
        'align-justify': align,
        hr: {
            i: 'ellipsis-h',
            click: function(e, $) {
                var dent = get_indent($.$().before);
                return $.tidy('\n\n', "").insert(dent + '<' + formats.hr + suffix + '\n\n', -1), false;
            }
        }
    });

    each(ui.tools, function(v, i) {
        var title = languages.tools[i] || "";
        if (is_function(v)) {
            ui.tools[i] = {
                title: title,
                click: v
            }
        } else {
            if (!v.title) v.title = title;
        }
    });

    extend(ui.keys, {
        'delete': 'clear',
        'control+delete': 's',
        'control+b': 'b',
        'control+i': 'i',
        'control+u': 'u',
        'control+l': 'a',
        'control+g': 'img',
        'control+arrowdown': 'sub',
        'control+arrowup': 'sup',
        'control+enter': 'p',
        'shift+enter': function(e, $) {
            var dent = get_indent($.$().before);
            return $.tidy('\n', "").insert(dent + '<' + formats.br + suffix + '\n', -1), false;
        },
        'enter': function(e, $) {
            var s = $.$(),
                v = $.get(),
                p = formats.p,
                li = formats.li,
                p_o = get_o(p),
                li_o = get_o(li),
                dent = get_indent(s.before), m, n;
            if (!s.length) {
                if (match = s.after.match(pattern('^\\s*<\\/(' + p_o + '|' + li_o + ')>'))) {
                    m = match[1];
                    ui.tools[m === 'li' ? tree_parent : m].click(e, $);
                } else if (auto_p && trim(v).length && s.end === v.length && /^\s*[^<\n]*?[^>]\s*$/.test(v)) {
                    v = '<' + p + '>' + v + '</' + p_o + '>\n<' + p + '>';
                    n = '</' + p_o + '>';
                    $.set(v + n).select(v.length);
                } else {
                    return; // normal enter key ...
                }
                return false;
            }
        },
        'backspace': function(e, $) {
            var s = $.$(), tag,
                before = s.before,
                after = s.after,
                end = '<[^<>]+?>';
            if (!s.length) {
                if (pattern(end + '$').test(before)) {
                    tag = before.split('<').pop().match(/^([^\/\s]+).*?>$/);
                    tag = (tag && tag[1]) || 0;
                    if (tag && pattern('^\\s*<\\/' + tag + '>').test(after)) {
                        $.unwrap(pattern('<' + tag + attrs + '>'), pattern('\\s*<\\/' + tag + '>'));
                    } else {
                        $.outdent(pattern(end));
                    }
                    return false;
                }
            }
        },
        'control+h': 'p,h1,h2,h3,h4,h5,h6',
        'control+q': 'blockquote,q',
        'control+k': 'pre,code',
        'control+-': 'ul',
        'control++': 'ol',
        'control+=': 'ol', // alias for `control++`
        'control+shift++': 'ol', // alias for `control++`
        'control+r': 'hr'
    });

    return editor.update();

};